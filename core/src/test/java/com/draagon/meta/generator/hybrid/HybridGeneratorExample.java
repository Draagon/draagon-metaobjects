package com.draagon.meta.generator.hybrid;

import com.draagon.meta.generator.direct.object.javacode.JavaCodeGenerator;
import com.draagon.meta.generator.direct.object.plugins.ValidationPlugin;
import com.draagon.meta.generator.direct.object.plugins.LombokPlugin;
import com.draagon.meta.generator.direct.object.plugins.JsonSerializationPlugin;
import com.draagon.meta.generator.direct.GenerationContext;
import com.draagon.meta.generator.direct.CodeFragment;
import com.draagon.meta.loader.MetaDataLoader;
import com.draagon.meta.loader.file.FileMetaDataLoader;

import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

/**
 * Example demonstrating both Enhanced Direct Generation and Hybrid Generation with scripts
 */
public class HybridGeneratorExample {
    
    private static final Logger log = LoggerFactory.getLogger(HybridGeneratorExample.class);
    
    private MetaDataLoader loader;
    private String outputDir;
    
    @Before
    void setUp() {
        // Initialize with sample metadata (in a real scenario, you'd load from XML/JSON)
        loader = createSampleLoader();
        outputDir = System.getProperty("java.io.tmpdir") + File.separator + "metaobjects-test";
        new File(outputDir).mkdirs();
        
        log.info("Test setup complete. Output directory: {}", outputDir);
    }
    
    /**
     * Example 1: Enhanced Direct Generation with Plugins
     */
    @Test
    void demonstrateEnhancedDirectGeneration() {
        log.info("=== Enhanced Direct Generation Example ===");
        
        try {
            JavaCodeGenerator generator = new JavaCodeGenerator();
            
            // Configure basic generation
            Map<String, String> args = new HashMap<>();
            args.put("outputDir", outputDir + File.separator + "enhanced");
            args.put("type", "interface");
            args.put("pkgPrefix", "com.example.generated");
            args.put("namePrefix", "I");
            args.put("nameSuffix", "Entity");
            
            generator.setArgs(args);
            
            // Add plugins for enhanced functionality
            generator.addPlugin(new ValidationPlugin()
                    .useJakartaValidation(true)
                    .addNotNullForRequired(true)
                    .addSizeForStringFields(true));
                    
            generator.addPlugin(new LombokPlugin()
                    .withBuilder()
                    .withAllArgsConstructor()
                    .withNoArgsConstructor());
                    
            generator.addPlugin(new JsonSerializationPlugin()
                    .useLibrary(JsonSerializationPlugin.JsonLibrary.JACKSON)
                    .addJsonPropertyAnnotations(true)
                    .addJsonIgnoreForSensitiveFields(true));
            
            // Execute generation
            generator.execute(loader);
            
            log.info("Enhanced direct generation completed successfully");
            
        } catch (Exception e) {
            log.error("Enhanced direct generation failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Example 2: Hybrid Generation with Custom Code Fragments
     */
    @Test 
    void demonstrateHybridGenerationWithCustomFragments() {
        log.info("=== Hybrid Generation with Custom Fragments Example ===");
        
        try {
            JavaCodeGenerator generator = new JavaCodeGenerator();
            
            // Configure generation  
            Map<String, String> args = new HashMap<>();
            args.put("outputDir", outputDir + File.separator + "fragments");
            args.put("type", "interface");
            args.put("pkgPrefix", "com.example.custom");
            
            generator.setArgs(args);
            
            // Customize code fragments
            GenerationContext context = new GenerationContext(loader);
            
            // Custom getter JavaDoc
            context.addCodeFragment("java.getter.javadoc", new CodeFragment(
                "/**\n" +
                " * Retrieves the ${field.name} value with validation\n" +
                " * @return ${field.javaType} the validated ${field.name}\n" +
                " * @since 1.0\n" +
                " * @apiNote This method is auto-generated\n" +
                " */"
            ));
            
            // Custom class header with additional annotations
            context.addCodeFragment("java.class.header", new CodeFragment(
                "/**\n" +
                " * Generated interface for ${object.name}\n" +
                " * @generated by MetaObjects Enhanced Generator\n" +
                " * @author MetaObjects Framework\n" +
                " * @version 1.0\n" +
                " */\n" +
                "@Generated(\"MetaObjects Enhanced Generator\")\n" +
                "@SuppressWarnings(\"all\")\n" +
                "public ${classType} ${className}${superClass} {"
            ));
            
            generator.withGlobalContext(context);
            generator.execute(loader);
            
            log.info("Hybrid generation with custom fragments completed successfully");
            
        } catch (Exception e) {
            log.error("Hybrid generation with custom fragments failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Example 3: Full Hybrid Generation with Groovy Scripts
     */
    @Test
    void demonstrateFullHybridGeneration() {
        log.info("=== Full Hybrid Generation with Scripts Example ===");
        
        try {
            HybridJavaCodeGenerator generator = new HybridJavaCodeGenerator();
            
            // Configure generation
            Map<String, String> args = new HashMap<>();
            args.put("outputDir", outputDir + File.separator + "scripted");
            args.put("type", "interface");
            args.put("pkgPrefix", "com.example.scripted");
            args.put("scriptEngine", "groovy");
            args.put("enableCaching", "true");
            
            generator.setArgs(args);
            
            // Add inline Groovy scripts for customization
            generator.addInlineScript(
                "// Custom field validation script\n" +
                "if (trigger == 'beforeField' && field != null) {\n" +
                "    if (field.name.endsWith('Email')) {\n" +
                "        writer.addScriptComment('Email field detected - adding email validation');\n" +
                "        writer.addScriptImport('jakarta.validation.constraints.Email');\n" +
                "    }\n" +
                "    if (field.name.toLowerCase().contains('password')) {\n" +
                "        writer.addScriptComment('Password field - marked as sensitive');\n" +
                "    }\n" +
                "}"
            );
            
            generator.addInlineScript(
                "// Custom getter naming for boolean fields\n" +
                "if (functionName == 'customizeGetterName' && field != null) {\n" +
                "    if (field.dataType.toString().toLowerCase().contains('bool')) {\n" +
                "        def fieldName = context.toCamelCase(field.name, true);\n" +
                "        return 'is' + fieldName;\n" +
                "    }\n" +
                "}\n" +
                "return defaultValue;"
            );
            
            generator.addInlineScript(
                "// Add custom methods for ID fields\n" +
                "if (trigger == 'afterField' && field != null) {\n" +
                "    if (field.name.endsWith('Id') || field.name.toLowerCase().equals('id')) {\n" +
                "        writer.writeScriptOutput('');\n" +
                "        writer.addScriptComment('Auto-generated helper method for ID field');\n" +
                "        def fieldName = context.toCamelCase(field.name, true);\n" +
                "        def fieldType = context.getJavaType(field);\n" +
                "        writer.writeScriptOutput('default boolean has' + fieldName + '() {');\n" +
                "        writer.writeScriptOutput('    return get' + fieldName + '() != null;');\n" +
                "        writer.writeScriptOutput('}');\n" +
                "    }\n" +
                "}"
            );
            
            // Add plugins as well
            generator.addPlugin(new ValidationPlugin());
            
            generator.execute(loader);
            
            log.info("Full hybrid generation with scripts completed successfully");
            
        } catch (Exception e) {
            log.error("Full hybrid generation failed: " + e.getMessage(), e);
            // Note: This might fail if Groovy is not on the classpath
            log.info("If this failed due to missing Groovy, add Groovy dependency to test classpath");
        }
    }
    
    /**
     * Creates a sample metadata loader for testing
     */
    private MetaDataLoader createSampleLoader() {
        // In a real scenario, you'd load from actual metadata files
        // For this example, we'll create a minimal loader
        // This is simplified - normally you'd use FileMetaDataLoader with actual XML/JSON files
        
        log.info("Creating sample metadata loader (normally would load from files)");
        
        try {
            // This would typically be:
            // return new FileMetaDataLoader("path/to/metadata/files");
            
            // For now, return a placeholder that would work if metadata files existed
            FileMetaDataLoader loader = new FileMetaDataLoader("test-file-loader");
            // loader.addSourceDirectory("src/test/resources/metadata");
            return loader;
            
        } catch (Exception e) {
            log.warn("Could not create file-based loader, using minimal loader: " + e.getMessage());
            return new MinimalTestLoader();
        }
    }
    
    /**
     * Minimal test loader that provides basic metadata for demonstration
     */
    static class MinimalTestLoader extends MetaDataLoader {
        
        public MinimalTestLoader() {
            super(new com.draagon.meta.loader.LoaderOptions(), "test");
            // In a real implementation, you'd add MetaObjects here
            log.info("MinimalTestLoader created - add MetaObjects programmatically for full testing");
        }
        
        @Override
        public MetaDataLoader init() {
            // Minimal initialization
            log.info("MinimalTestLoader initialized");
            return super.init();
        }
    }
}

/**
 * Additional utility class showing advanced hybrid generation patterns
 */
class AdvancedHybridPatterns {
    
    private static final Logger log = LoggerFactory.getLogger(AdvancedHybridPatterns.class);
    
    /**
     * Example showing how to create reusable script libraries
     */
    public static void demonstrateScriptLibraries() {
        log.info("=== Script Libraries Example ===");
        
        // Create a reusable script for common field processing
        String fieldUtilsScript = 
            "// Reusable field utilities\n" +
            "class FieldUtils {\n" +
            "    static boolean isNumericType(field) {\n" +
            "        return field.dataType.toString().toLowerCase().matches('(int|long|float|double|decimal|number)');\n" +
            "    }\n" +
            "    \n" +
            "    static boolean isRequiredField(field) {\n" +
            "        return field.required || field.hasAttribute('required');\n" +
            "    }\n" +
            "    \n" +
            "    static String getValidationAnnotation(field) {\n" +
            "        if (isRequiredField(field)) return '@NotNull';\n" +
            "        if (isNumericType(field) && field.hasAttribute('min')) {\n" +
            "            return '@Min(' + field.getAttributeValueAsString('min') + ')';\n" +
            "        }\n" +
            "        return null;\n" +
            "    }\n" +
            "}\n" +
            "\n" +
            "// Make utils available to other scripts\n" +
            "context.setScriptVariable('FieldUtils', FieldUtils);";
        
        log.info("Script libraries allow for reusable, modular generation logic");
    }
    
    /**
     * Example showing conditional generation based on metadata attributes
     */
    public static void demonstrateConditionalGeneration() {
        log.info("=== Conditional Generation Example ===");
        
        String conditionalScript = 
            "// Generate different code based on object type\n" +
            "if (trigger == 'beforeObject' && object != null) {\n" +
            "    if (object.hasAttribute('entity')) {\n" +
            "        writer.addScriptImport('jakarta.persistence.*');\n" +
            "        writer.addScriptComment('JPA Entity configuration');\n" +
            "    }\n" +
            "    \n" +
            "    if (object.hasAttribute('restController')) {\n" +
            "        writer.addScriptImport('org.springframework.web.bind.annotation.*');\n" +
            "        writer.addScriptComment('REST Controller configuration');\n" +
            "    }\n" +
            "    \n" +
            "    if (object.hasAttribute('auditEnabled')) {\n" +
            "        writer.writeScriptOutput('@Audited');\n" +
            "        writer.addScriptImport('org.hibernate.envers.Audited');\n" +
            "    }\n" +
            "}";
        
        log.info("Conditional generation enables metadata-driven customization");
    }
}

/**
 * Configuration examples for various use cases
 */
class GenerationConfigurations {
    
    /**
     * Configuration for REST API DTOs with validation
     */
    public static Map<String, String> getRestApiDtoConfig() {
        Map<String, String> config = new HashMap<>();
        config.put("type", "class");
        config.put("pkgSuffix", "dto");
        config.put("nameSuffix", "Dto");
        config.put("plugins", "validation,jackson");
        return config;
    }
    
    /**
     * Configuration for JPA entities
     */
    public static Map<String, String> getJpaEntityConfig() {
        Map<String, String> config = new HashMap<>();
        config.put("type", "class");
        config.put("pkgSuffix", "entity");
        config.put("namePrefix", "");
        config.put("nameSuffix", "Entity");
        config.put("plugins", "lombok,jpa,validation");
        return config;
    }
    
    /**
     * Configuration for GraphQL types
     */
    public static Map<String, String> getGraphQLConfig() {
        Map<String, String> config = new HashMap<>();
        config.put("type", "class");
        config.put("pkgSuffix", "graphql");
        config.put("nameSuffix", "Type");
        config.put("plugins", "graphql,jackson");
        return config;
    }
}