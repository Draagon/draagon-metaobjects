package com.draagon.meta.constraint;

import com.draagon.meta.MetaData;

/**
 * PlacementConstraint defines WHERE a MetaData type can be placed in the metadata hierarchy
 * using simple string patterns for easy generator integration.
 *
 * Pattern Examples:
 * - "object.*" - any object subtype
 * - "field.string" - specific field.string subtype
 * - "metadata.root" - specific metadata root type
 *
 * Abstract Requirements:
 * - MUST_BE_ABSTRACT: Child must have isAbstract=true (default for metadata.root)
 * - MUST_BE_CONCRETE: Child must have isAbstract=false
 * - ANY: Can be abstract or concrete (default for most cases)
 */
public class PlacementConstraint implements Constraint {

    private final String parentPattern;
    private final String childPattern;
    private final PlacementPolicy policy;
    private final AbstractRequirement abstractRequirement;

    /**
     * Create a placement constraint with simple pattern matching
     * @param parentPattern Pattern for parent type (e.g., "object.*", "metadata.root")
     * @param childPattern Pattern for child type (e.g., "field.*", "attr.string")
     * @param policy Whether this placement is ALLOWED or FORBIDDEN
     */
    public PlacementConstraint(String parentPattern, String childPattern, PlacementPolicy policy) {
        this(parentPattern, childPattern, policy, AbstractRequirement.ANY);
    }

    /**
     * Create a placement constraint with abstract requirements
     * @param parentPattern Pattern for parent type (e.g., "object.*", "metadata.root")
     * @param childPattern Pattern for child type (e.g., "field.*", "attr.string")
     * @param policy Whether this placement is ALLOWED or FORBIDDEN
     * @param abstractRequirement Whether child must be abstract, concrete, or either
     */
    public PlacementConstraint(String parentPattern, String childPattern,
                              PlacementPolicy policy, AbstractRequirement abstractRequirement) {
        this.parentPattern = parentPattern;
        this.childPattern = childPattern;
        this.policy = policy;
        this.abstractRequirement = abstractRequirement;
    }

    /**
     * Check if a parent matches the parent pattern
     * @param parent The parent MetaData
     * @return True if parent matches this constraint's parent pattern
     */
    public boolean matchesParentPattern(MetaData parent) {
        return matchesPattern(parent, parentPattern);
    }

    /**
     * Check if a child matches the child pattern
     * @param child The child MetaData
     * @return True if child matches this constraint's child pattern
     */
    public boolean matchesChildPattern(MetaData child) {
        return matchesPattern(child, childPattern);
    }

    /**
     * Check if this constraint applies to the given parent-child relationship
     * @param parent The parent MetaData
     * @param child The child MetaData
     * @return True if this constraint should be checked for this relationship
     */
    public boolean appliesTo(MetaData parent, MetaData child) {
        return matchesParentPattern(parent) && matchesChildPattern(child);
    }

    /**
     * Check if a MetaData matches a pattern like "object.*" or "field.string"
     * @param metaData The MetaData to check
     * @param pattern The pattern to match (type.subtype or type.*)
     * @return True if the MetaData matches the pattern
     */
    private boolean matchesPattern(MetaData metaData, String pattern) {
        String[] parts = pattern.split("\\.");
        if (parts.length != 2) {
            return false; // Invalid pattern
        }

        String patternType = parts[0];
        String patternSubType = parts[1];

        // Check type match
        if (!patternType.equals(metaData.getType())) {
            return false;
        }

        // Check subtype match (* means any subtype)
        if ("*".equals(patternSubType)) {
            return true;
        }

        return patternSubType.equals(metaData.getSubType());
    }

    @Override
    public void validate(MetaData metaData, Object value)
            throws ConstraintViolationException {
        // PlacementConstraints are validated during addChild operations, not during value validation
        throw new UnsupportedOperationException(
            "PlacementConstraint validation should be called via appliesTo(), not validate()");
    }

    @Override
    public String getType() {
        return "placement";
    }

    @Override
    public String getDescription() {
        return String.format("%s %s can %s %s",
            parentPattern,
            policy == PlacementPolicy.ALLOWED ? "can contain" : "cannot contain",
            abstractRequirement == AbstractRequirement.MUST_BE_ABSTRACT ? "abstract" :
            abstractRequirement == AbstractRequirement.MUST_BE_CONCRETE ? "concrete" : "any",
            childPattern);
    }

    /**
     * Get the parent pattern
     * @return The parent pattern string (e.g., "object.*")
     */
    public String getParentPattern() {
        return parentPattern;
    }

    /**
     * Get the child pattern
     * @return The child pattern string (e.g., "field.*")
     */
    public String getChildPattern() {
        return childPattern;
    }

    /**
     * Get the placement policy
     * @return Whether this placement is ALLOWED or FORBIDDEN
     */
    public PlacementPolicy getPolicy() {
        return policy;
    }

    /**
     * Check if this placement is allowed
     * @return True if policy is ALLOWED
     */
    public boolean isAllowed() {
        return policy == PlacementPolicy.ALLOWED;
    }

    /**
     * Get the abstract requirement
     * @return The abstract requirement for this placement
     */
    public AbstractRequirement getAbstractRequirement() {
        return abstractRequirement;
    }

    @Override
    public String toString() {
        return "PlacementConstraint{" +
               "parent='" + parentPattern + '\'' +
               ", child='" + childPattern + '\'' +
               ", policy=" + policy +
               ", abstract=" + abstractRequirement +
               '}';
    }
}
